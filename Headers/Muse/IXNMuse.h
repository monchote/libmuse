// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from sdk_bridge.djinni

#import "IXNConnectionState.h"
#import "IXNMuseConnectionListener.h"
#import "IXNMuseDataListener.h"
#import "IXNMuseDataPacketType.h"
#import "IXNMusePreset.h"
#import "IXNNotchFrequency.h"
#import <Foundation/Foundation.h>
@class IXNMuseConfiguration;
@class IXNMuseVersion;

/**
 * Provides the client interface to a specific %Muse Headband.
 *
 * This class maps to a single %Muse Headband, providing an API for receiving
 * connection events and data packets, as well as the ability to inspect
 * various properties of the headband it corresponds to. Users can initiate
 * and halt a connection to the device, enable data transmission, find out
 * the human-readable name of the headband, etc.
 *
 * This class should never be constructed directly by a user; rather,
 * references to it can be retrieved from MuseManager.
 *
 * There are two main ways of interacting with a Muse:
 *   1. calling runAsynchronously() and having the connection lifetime and
 *      stream events managed out of band by either a separate thread (on e.g.
 *      Android) or a run loop (on e.g. iOS).
 *   2. calling connect() on your own and then polling on execute().
 *
 * In case 1, you needn't and shouldn't call connect() or execute() on your own.
 * Everything is taken care of for the duration of the connection (i.e. until
 * you receive a disconnected event).
 */

@protocol IXNMuse

/**
 * Initiate a connection to a Muse headband.
 *
 * On iOS, this call is non-blocking and returns immediately; it only
 * signals your intent to initiate a streaming session with the headband. On
 * Android, this blocks pending the creation of an OS-level bluetooth
 * socket. In both cases, you should call execute() in a loop or timer to
 * finish the connection process.
 *
 * Note that since this returns before the connection is established, you
 * should instead use a connection listener (Android:
 * MuseConnectionListener; iOS: IXNMuseConnectionListener) to implement any
 * logic, such as updating a UI element, on successful connection.
 *
 * <b>Threading:</b> method is thread-safe.
 */
- (void)connect;

/**
 * Disconnects your mobile device from %Muse Headband.
 *
 * You can unregister all listeners or you can leave them if you plan
 * to connect again.
 *
 * <B>Threading:</B> method is thread-safe. <br>
 * <B>Important:</B> Listeners will be unregistered at the end, <B>after</B>
 * bluetooth connection is dropped and <B>disconnection event is sent</B>.
 * If you don't want to receive disconnection event, unregister listeners
 * manually first.
 */
- (void)disconnect:(BOOL)unregisterListeners;

/**
 * Runs a single, non-blocking step of processing.
 *
 * Reads data from Bluetooth if there is any; updates the connection state;
 * sends packets to listeners; etc. This should be called relatively
 * frequently: max 250ms, ideally 20ms.
 *
 * If you are listening for computed values (e.g. band powers) rather than
 * just raw EEG samples, then be aware that this method may trigger some
 * amount of processing in the foreground before it returns. If this has
 * undesirable effects on app performance, then you may want to move it to a
 * dedicated thread.
 *
 * Also be aware that all packets will be received on the same thread as
 * execute() is run.
 *
 * <B>Threading:</b> This method is NOT thread safe. You must synchronize
 * the Muse object on your own if you wish to call it concurrently from more
 * than one thread.
 */
- (void)execute;

/**
 * Connect to a headband out of the main logic flow.
 *
 * This method handles all the connection logic for a single connection to a
 * headband (i.e. starting with issuing a "connecting" event and ending with
 * issuing a "disconnected" event). It may run in a separate thread or an
 * event loop on the main thread; the details are platform-specific.
 *
 * If this method is used, then on iOS, all packets are delivered on the
 * main thread. On Android, all packets are delivered on a specific thread
 * that is not the UI thread.
 *
 * The lifetime of effect of this method ends on disconnection; if you want
 * to initiate a new connection to a headband that has disconnected, you
 * should call runAsynchronously on it again.
 *
 * If this method is called multiple times within the lifetime of a single
 * connection, any subsequent calls will do nothing other than print a log
 * message.
 *
 * <B>Threading:</B> This method is thread safe.
 */
- (void)runAsynchronously;

/**
 * Returns current connection state. <br>
 * <B>Threading:</B> method is thread-safe.
 */
- (IXNConnectionState)getConnectionState;

/**
 * Returns Bluetooth MAC address of %Muse Headband. <br>
 * <B>Threading:</B> method is thread-safe.
 */
- (NSString *)getMacAddress;

/**
 * Returns Bluetooth name of %Muse Headband. <br>
 * <B>Threading:</B> method is thread-safe.
 */
- (NSString *)getName;

/**
 * Returns struct which contains all information about
 * Muse configuration. Muse Configuration object is populated during
 * connection routine or after headband settings (like preset or
 * notch frequency) are changed<br>
 * <B>Threading:</B> method is thread-safe.
 */
- (IXNMuseConfiguration *)getMuseConfiguration;

/**
 * Returns struct, which contains all information about
 * Muse version. Muse Version is populated during connection routine only <br>
 * <B>Threading:</B> method is thread-safe.
 */
- (IXNMuseVersion *)getMuseVersion;

/**
 * Registers connection listener. Same listener cannot be registered
 * twice. If such listener was already registered, then method does nothing.
 * <br>
 * <B> Threading: </B> method is thread-safe.
 */
- (void)registerConnectionListener:(id <IXNMuseConnectionListener>)listener;

/**
 * Unregisters connection listeners. <br>
 * <B> Threading: </B> method is thread-safe.
 */
- (void)unregisterConnectionListener:(id <IXNMuseConnectionListener>)listener;

/**
 * Registers one or many data listeners. You can register the same listener
 * to listen for different packet types - just call this method again.
 * It's your responsibility to make sure that the listener handles all packet
 * types correctly.
 * If a listener was already registered for this specific type then
 * method does nothing. <br>
 * <B> Threading: </B> method is thread-safe.
 */
- (void)registerDataListener:(id <IXNMuseDataListener>)listener type:(IXNMuseDataPacketType)type;

/**
 * Unregisters specific data listener, which was registered before.
 * If listener was not registered before, then method does nothing. <br>
 * <B>Threading:</B> method is thread-safe.
 */
- (void)unregisterDataListener:(id <IXNMuseDataListener>)listener type:(IXNMuseDataPacketType)type;

/**
 * Method unregisters all registered connection listeners and data
 * listeners. This method can also be executed by disconnect() with
 * appropriate arguments. <br>
 * <B>Threading:</B> method is thread-safe.
 */
- (void)unregisterAllListeners;

/**
 * Changes %Muse Headband settings. Look at https://sites.google.com/a/interaxon.ca/muse-developer-site/museio/presets for details. <br>
 * <B> Threading: </B> method is thread-safe.
 * You can call it in the middle of execute operation, but in this case
 * be aware that this operation will interrupt data streaming to set new
 * preset. Data streaming will be restored after that.
 * If method is called before connection is established, the right setting
 * will be passed to device during connection routine.
 */
- (void)setPreset:(IXNMusePreset)preset;

/**
 * Starts/stops data transmission (but keep-alive packets will be still sent).
 * If you're using low-level interface (connect + execute), you should
 * still call execute() to continue sending keep-alive messages.
 * If you're using runAsynchronously(), then it will take care about
 * sending keep-alive packets. <br>
 * <B>Threading:</B> method is thread-safe. You can call it in the middle
 * of execute operation.
 * If method is called before connection is established, the right setting
 * will be passed to device during connection routine.
 */
- (void)enableDataTransmission:(BOOL)enable;

/**
 * Changes notch frequency (power line frequency). <br>
 * <B>Threading:</B> method is thread-safe.
 * You can call it in the middle of execute operation, but in this case
 * be aware that this operation will interrupt data streaming to set new
 * notch frequency. Data streaming will be restored after that.
 * If method is called before connection is established, the right setting
 * will be passed to device during connection routine.
 */
- (void)setNotchFrequency:(IXNNotchFrequency)newFrequency;

@end
